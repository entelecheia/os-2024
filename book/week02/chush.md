# Lab - Shell

이 프로젝트에서는 기본적인 Unix 셸을 구현할 것입니다. 이 셸은 명령어를 입력받아 해당 명령어를 실행하는 아주 간단한 구조로 되어 있습니다. 이 과정을 통해 리눅스 프로그래밍 환경에 익숙해지고, 프로세스 생성, 관리, 소멸에 대해 배우며, 셸이 필요로 하는 기본적인 기능들을 경험하게 됩니다.

```{admonition} 리눅스 셸(Linux Shell)
리눅스 셸(Linux Shell)은 사용자와 운영체제 간의 상호작용을 위한 인터페이스를 제공합니다. 다양한 종류의 셸이 있으며, 각각은 독특한 특징과 사용 방법을 가지고 있습니다. 여기서는 몇 가지 주요 리눅스 셸(Bash, Zsh, Fish)에 대해 소개하고, 기능 및 사용법을 비교해 보겠습니다.

**Bash (Bourne-Again SHell)**

- **특징:** 가장 흔히 사용되는 셸로, 많은 리눅스 배포판의 기본 셸입니다. 강력한 프로그래밍 기능을 제공하며, 스크립트 작성과 작업 자동화에 유용합니다.
- **사용법 예시:**
  - 파일 목록 보기: `ls`
  - 현재 작업 디렉토리 확인: `pwd`
  - 파일 복사: `cp source.txt destination.txt`
- **장점:** 널리 사용되어 자료가 풍부하며, 다양한 스크립트와 호환됩니다.
- **단점:** 다른 셸에 비해 사용자 친화적인 기능이 부족할 수 있습니다.

**Zsh (Z Shell)**

- **특징:** Bash의 기능을 포함하면서 사용자 친화적인 기능을 많이 추가한 셸입니다. 테마와 플러그인을 통해 매우 커스터마이징이 가능합니다.
- **사용법 예시:**
  - 자동 완성 기능을 사용하여 효율적인 명령 입력이 가능합니다.
  - `oh-my-zsh`를 설치하여 다양한 테마와 플러그인을 쉽게 적용할 수 있습니다.
- **장점:** 매우 유연하고 사용자 친화적입니다. 다양한 개선 사항으로 작업 효율이 높아집니다.
- **단점:** 초기 설정이 Bash보다 복잡할 수 있습니다.

**Fish (Friendly Interactive SHell)**

- **특징:** 사용의 편의성을 최우선으로 설계된 셸입니다. 기본 설정만으로도 풍부한 기능을 제공합니다.
- **사용법 예시:**
  - 실시간으로 표시되는 명령어 자동 완성 기능이 있습니다.
  - 명령어 실행 이력에서 쉽게 명령어를 검색하고 재사용할 수 있습니다.
- **장점:** 사용하기 쉽고 직관적인 인터페이스를 제공합니다.
- **단점:** Bash나 Zsh에 비해 호환성 문제가 발생할 수 있습니다.


각 셸은 고유의 특징과 장단점을 가지고 있으며, 사용자의 선호도나 필요에 따라 선택할 수 있습니다. Bash는 전통적이고 강력한 스크립팅이 필요할 때 좋으며, Zsh는 사용자 경험과 커스터마이징을 중시할 때, Fish는 쉽고 빠르게 셸을 사용하고 싶을 때 추천됩니다.
```

## 프로그램 명세

### 기본 셸: `chesh`

당신의 기본 셸, `chesh`(Cheju Shell의 약자)는 사용자로부터 명령어를 입력받아 실행하고 결과를 출력하는 반복 구조를 가집니다. 사용자가 `exit`를 입력하기 전까지 이 과정은 계속됩니다.

- 인터랙티브 모드: 사용자가 직접 명령어를 입력할 수 있습니다.
- 배치 모드: 명령어가 담긴 파일을 읽어 해당 명령어들을 순차적으로 실행합니다.

### 명령어 실행

- 셸은 각 명령어를 별도의 프로세스로 실행해야 합니다(`fork()`, `exec()`, `wait()` 사용).
- 초기 셸 경로는 `/bin` 디렉토리를 포함해야 합니다.

### 내장 명령어

- `exit`: 셸을 종료합니다.
- `cd`: 현재 디렉토리를 변경합니다.
- `path`: 실행 파일을 검색할 경로를 설정합니다.

### 프로그램 오류 처리

- 오류 발생 시 "An error has occurred\n" 메시지를 출력하고, 적절하게 처리합니다.

## 구현 팁

1. **기본 기능 구현**: 한 번에 하나의 명령어 실행에서 시작합니다.
2. **내장 명령어 추가**: `exit`, `cd`, `path` 같은 내장 명령어를 구현합니다.
3. **입력 처리**: 공백, 탭 등 다양한 공백 문자를 적절히 처리할 수 있도록 합니다.
4. **오류 검사**: 모든 시스템 호출의 반환값을 검사하여 오류를 적절히 처리합니다.
5. **테스트**: 다양한 입력과 상황을 가정하여 셸이 올바르게 동작하는지 테스트합니다.

이 프로젝트를 통해, 당신은 리눅스 셸이 어떻게 동작하는지, 그리고 운영체제와 사용자 사이에서 어떠한 역할을 하는지에 대해 깊이 이해하게 될 것입니다.

## 예제 코드

예제 코드는 [`src/ostep/processes-shell/chesh.c`](https://github.com/chu-aie/os-2024/blob/entelecheia/issue31/src/ostep/processes-shell/chesh.c)에 있습니다. 이 코드는 `chesh` 셸의 기본적인 동작을 보여주며, 추가적인 기능을 구현하여 확장할 수 있습니다.

## 실행 방실

리눅스 환경에서 위의 기본적인 셸 프로그램 `chesh`를 컴파일하고 실행하는 방법을 단계별로 설명하겠습니다. 이 튜토리얼은 GCC(GNU Compiler Collection)가 설치된 리눅스 시스템을 기준으로 합니다.

### 1단계: 코드 저장하기

위에서 제공된 C 코드를 `chesh.c`라는 이름의 파일로 저장합니다. 이 작업은 텍스트 에디터를 사용하여 수행할 수 있습니다. 예를 들어, `nano`, `vim`, `gedit` 등의 에디터를 사용할 수 있습니다.

```bash
nano chesh.c
```

위 명령어는 `nano` 텍스트 에디터를 사용하여 새 파일을 생성하거나 기존 파일을 편집할 때 사용합니다. 위 코드를 복사하여 에디터에 붙여넣고 저장 후 종료합니다(`Ctrl + X`, `Y`를 누르고 `Enter`를 눌러 저장).

### 2단계: 코드 컴파일하기

`gcc`를 사용하여 `chesh.c` 소스 파일을 컴파일하고 실행 파일을 생성합니다. 다음 명령어를 사용합니다:

```bash
gcc chesh.c -o chesh
```

이 명령어는 `chesh.c` 파일을 컴파일하여 `chesh`라는 실행 파일을 생성합니다. `-o chesh` 옵션은 출력 파일의 이름을 지정합니다.

### 3단계: 셸 실행하기

컴파일이 성공적으로 완료되면, 생성된 `chesh` 실행 파일을 다음과 같이 실행할 수 있습니다:

```bash
./chesh
```

이 명령어는 현재 디렉토리에 있는 `chesh` 실행 파일을 실행합니다. 성공적으로 실행되면, 사용자에게 명령어 입력을 위한 프롬프트 `chesh> `가 표시됩니다.

### 4단계: 명령어 실행하기

`chesh` 셸이 실행되고 나면, 다양한 리눅스 명령어를 입력하여 실행할 수 있습니다. 예를 들어, 현재 디렉토리의 파일 목록을 보려면 `ls` 명령어를 사용합니다:

```bash
chesh> ls
```

또는 현재 디렉토리를 변경하려면 `cd` 명령어와 함께 원하는 경로를 입력합니다:

```bash
chesh> cd /path/to/directory
```

### 5단계: `chesh` 종료하기

`chesh` 셸을 종료하려면, 내장 명령어인 `exit`을 입력합니다:

```bash
chesh> exit
```

이 튜토리얼을 따라 하면, 기본적인 셸 프로그램 `chesh`를 컴파일하고 실행하여 간단한 명령어를 수행할 수 있습니다. 추가 기능이나 개선이 필요한 경우, 소스 코드를 수정하여 더 많은 기능을 구현할 수 있습니다.
