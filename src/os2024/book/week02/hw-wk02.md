# Homework: 프로세스

| [추상화: 프로세스](http://www.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf) | [process-run.py 실행](https://github.com/entelecheia/os-2024/tree/main/src/ostep-homework/cpu-intro) |

```{note}
본 과제는 프로젝트를 위해 생성한 본인의 개별 폴더에 제출하기 바랍니다. 제출기한은 5/1(수)입니다.
```

## 소개

이 프로그램 `process-run.py`를 통해 프로그램이 실행되고 CPU를 사용하거나(예: 명령어 추가 수행) I/O를 수행할 때(예: 디스크에 요청을 보내고 완료될 때까지 기다림) 프로세스 상태가 어떻게 변하는지 볼 수 있습니다. 자세한 내용은 README를 참조하세요.

## 질문

1. 다음 플래그와 함께 `process-run.py`를 실행하세요: `-l 5:100,5:100`. CPU 활용률(예: CPU가 사용 중인 시간의 백분율)은 어떻게 되어야 할까요? 왜 그렇게 알 수 있나요? `-c`와 `-p` 플래그를 사용해 여러분의 생각이 맞는지 확인해 보세요.

2. 이제 다음 플래그로 실행해 보세요: `./process-run.py -l 4:100,1:0`. 이 플래그는 4개의 명령어(모두 CPU 사용)를 가진 하나의 프로세스와 I/O를 실행하고 완료될 때까지 기다리는 하나의 프로세스를 지정합니다. 두 프로세스를 모두 완료하는 데 얼마나 걸리나요? `-c`와 `-p`를 사용해 여러분의 생각이 맞는지 확인해 보세요.

3. 프로세스의 순서를 바꿔 보세요: `-l 1:0,4:100`. 이제 어떻게 되나요? 순서를 바꾸는 것이 중요한가요? 왜 그런가요? (항상 그렇듯이 `-c`와 `-p`를 사용해 여러분의 생각이 맞는지 확인해 보세요)

4. 이제 다른 플래그들을 살펴보겠습니다. 중요한 플래그 중 하나는 `-S`인데, 이는 프로세스가 I/O를 실행할 때 시스템이 어떻게 반응하는지 결정합니다. 플래그를 `SWITCH_ON_END`로 설정하면 한 프로세스가 I/O를 수행하는 동안 시스템은 다른 프로세스로 전환하지 않고 해당 프로세스가 완전히 끝날 때까지 기다립니다. 다음 두 프로세스를 실행할 때 어떤 일이 일어나나요(`-l 1:0,4:100 -c -S SWITCH_ON_END`), 하나는 I/O를 수행하고 다른 하나는 CPU 작업을 수행합니다?

5. 이제 같은 프로세스를 실행하되, 한 프로세스가 I/O를 기다리는(`WAITING`) 동안 다른 프로세스로 전환되도록 switching 동작을 설정해 봅시다(`-l 1:0,4:100 -c -S SWITCH_ON_IO`). 이제 어떤 일이 일어나나요? `-c`와 `-p`를 사용해 여러분의 생각이 맞는지 확인해 보세요.

6. 또 다른 중요한 동작은 I/O가 완료될 때 수행할 작업입니다. `-I IO_RUN_LATER`를 사용하면 I/O가 완료될 때 그것을 실행한 프로세스가 반드시 즉시 실행되는 것은 아닙니다. 오히려 그 시점에 실행 중이던 프로세스가 계속 실행됩니다. 이러한 프로세스 조합을 실행하면 어떤 일이 일어나나요? (`./process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_LATER -c -p`) 시스템 자원이 효율적으로 활용되고 있나요?

7. 이제 같은 프로세스를 실행하되, `-I IO_RUN_IMMEDIATE`를 설정해 I/O를 실행한 프로세스를 즉시 실행하도록 해 봅시다. 이 동작은 어떻게 다른가요? 방금 I/O를 완료한 프로세스를 다시 실행하는 것이 왜 좋은 생각일 수 있을까요?

8. 이제 무작위로 생성된 프로세스로 실행해 봅시다: `-s 1 -l 3:50,3:50` 또는 `-s 2 -l 3:50,3:50` 또는 `-s 3 -l 3:50,3:50`. 추적 결과가 어떻게 될지 예측해 보세요. `-I IO_RUN_IMMEDIATE` 플래그와 `-I IO_RUN_LATER` 플래그를 사용할 때 어떤 일이 일어나나요? `-S SWITCH_ON_IO`와 `-S SWITCH_ON_END`를 사용할 때 어떤 일이 일어나나요?

## 용어 설명

- **프로세스(Process)**: 실행 중인 프로그램의 인스턴스입니다. 프로세스는 자체 메모리 공간을 가지며 CPU 시간을 할당받습니다.

- **CPU 활용률(CPU Utilization)**: CPU가 작업을 수행하는 데 사용되는 시간의 비율입니다. 높은 CPU 활용률은 CPU가 효율적으로 사용되고 있음을 의미합니다.

- **I/O**: Input/Output의 약자로, 프로세스가 디스크, 네트워크 등의 외부 장치와 통신하는 것을 말합니다. I/O 작업은 일반적으로 CPU 작업보다 훨씬 더 많은 시간이 걸립니다.

- **문맥 교환(Context Switch)**: 한 프로세스에서 다른 프로세스로 CPU 제어를 전환하는 프로세스입니다. 문맥 교환에는 현재 프로세스의 상태를 저장하고 새 프로세스의 상태를 로드하는 작업이 포함됩니다.

- **스케줄링(Scheduling)**: 어떤 프로세스가 CPU 시간을 받을지 결정하는 프로세스입니다. 운영 체제의 스케줄러는 공정성과 효율성의 균형을 유지하려고 합니다.

## 코드 예제

`process-run.py` 프로그램을 실행하는 방법의 예입니다:

```bash
# 두 개의 프로세스를 실행하고 CPU 활용률과 각 프로세스의 통계를 출력합니다
./process-run.py -l 5:100,5:100 -c -p

# I/O 완료 시 프로세스 전환 동작을 설정하고 결과를 출력합니다
./process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_LATER -c -p

# 무작위 프로세스를 생성하고 실행합니다
./process-run.py -s 1 -l 3:50,3:50 -c -p
```

이러한 예제는 `process-run.py` 프로그램의 다양한 옵션과 플래그를 보여줍니다. `-l` 플래그는 프로세스 목록을 지정하고, `-c`와 `-p`는 각각 CPU 활용률과 프로세스 통계를 출력합니다. `-S`와 `-I` 플래그는 I/O와 관련된 스케줄링 동작을 제어합니다.

## 결론

이 과제는 프로세스, I/O, 스케줄링과 같은 운영 체제의 핵심 개념을 탐구할 수 있는 기회를 제공합니다. `process-run.py` 프로그램을 사용하면 다양한 시나리오를 시뮬레이션하고 결과를 관찰할 수 있습니다.

프로세스가 CPU 작업과 I/O 작업을 수행할 때 프로세스 상태가 어떻게 변하는지, 스케줄링 정책이 시스템 성능에 어떤 영향을 미치는지 이해하는 것이 중요합니다. 문맥 교환에는 오버헤드가 수반되므로 너무 자주 발생하면 성능이 저하될 수 있습니다. 그러나 I/O를 기다리는 동안 다른 프로세스를 실행하면 CPU를 더 효율적으로 활용할 수 있습니다.

다양한 플래그와 옵션을 사용하여 실험함으로써 이러한 개념을 직접 경험할 수 있습니다. 결과를 예측해 보고 `-c`와 `-p` 출력을 사용하여 검증해 보세요. 직관과 일치하지 않는 것이 있다면 그 이유를 파악해 보세요.

운영 체제가 어떻게 프로세스를 관리하고 컴퓨터 자원을 할당하는지 이해하는 것은 효율적이고 안정적인 소프트웨어를 설계하는 데 있어 필수적입니다. 이 과제는 그 방향으로 나아가는 작지만 중요한 첫걸음입니다. 계속해서 탐구하고 배우세요!
